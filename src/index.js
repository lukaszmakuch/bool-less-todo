import makeStorage from 'rosmaro-in-memory-storage';
import makeLock from 'rosmaro-process-wide-lock';
import RosmaroReact from 'rosmaro-react';
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import registerServiceWorker from './registerServiceWorker';
import {lens, update, map, prop, reverse, values, keys} from 'ramda';
// This graph has been generated using the Rosmaro Editor (rosmaro.js.org/editor).
import graph from './graph.json'; 

// A single item focuses on a slice of the context. 
// For example
// The whole context is like {newItemText: 'writing', items: ['first', 'second']}
// The lens for the second Item graph (generated by the *Items* dynamic composite)
// turns it into {title: 'second', id: '1'}
const Item = {
  ctxLens: ({localNodeName}) => lens(
    (ctx) => ({
      id: localNodeName,
      title: ctx.items[localNodeName]
    }),
    ({title}, ctx) => ({
      ...ctx, 
      items: update(parseInt(localNodeName, 10), title, ctx.items)
    })
  )
};

// Clicking an item makes is follow the *clicked* arrow.
const clickItem = () => ({'arrow': 'clicked'});

// A done item.
const DoneItem = {
  // This is how does it look and behave, when it's rendered.
  render: ({ctx: {title, id}, thisModelNode}) => {
    const view = <li className="done" onClick={() => thisModelNode.clickItem()} key={id}>
      {title}
    </li>;
    // Navigation returns a function, which picks one of these.
    // A done item doesn't display when we want to display just undone ones.
    return {
      all: view,
      done: view,
      undone: null,
    };
  },
  clickItem
};

// An undone item.
const UndoneItem = {
  render: ({ctx: {title, id}, thisModelNode}) => {
    // This is how does it look and behave, when it's rendered.
    const view = <li className="undone" onClick={() => thisModelNode.clickItem()} key={id}>
      {title}
    </li>;
    // Navigation returns a function, which picks one of these.
    // An undone item doesn't render when we want to display just done ones.
    return {
      all: view,
      done: null,
      undone: view,
    };
  },
  clickItem
};

// A list of all items.
const Items = {
  // The children are named after indexes of items.
  nodes: ({ctx}) => keys(ctx.items),
  // New items are added at the end of the list 
  // (see the NewItemFormView comments for more details),
  // but we want the recent item to be at the top. 
  // That's why we render them in the reversed order.
  afterRender: ({res}) => reverse(values(res))
};

// The form used to add a new item.
const NewItemFormView = {
  // A transition is the only way how the context of the model may change.
  // That's why when the user types something, 
  // we follow an arrow to update the context.
  type: ({ctx, newItemText}) => ({
    arrow: 'typed',
    ctx: {...ctx, newItemText}
  }),
  // Adding an item means erasing the entered text (newItemText)
  // and adding it to the list of items.
  // It's added at the end, because indexes of this array are used
  // as node names in the *Items* dynamic composite. 
  addItem: ({ctx}) => ({
    arrow: 'item added',
    ctx: {
      ...ctx,
      newItemText: '',
      items: [...ctx.items, ctx.newItemText]
    }
  }),
  render: ({ctx, thisModel}) => 
    <form>
      <input
        type="text"
        className="item-form-field"
        value={ctx.newItemText}
        onChange={e => thisModel.type({newItemText: e.target.value})}
        />
      <input
        type="button"
        className="item-form-button"
        value="Add"
        onClick={() => thisModel.addItem()}
        />
    </form>
};

// What happens when the following model methods are called.
const navigationHandlers = {
  // When we call .navigateToAll, 
  // the node which handles this call follows the 'navigating to all arrow'.
  navigateToAll: () => ({arrow: 'navigating to all'}),
  navigateToDone: () => ({arrow: 'navigating to done'}),
  navigateToUndone: () => ({arrow: 'navigating to undone'}),
};

// Builds an inactive button which when clicked calls the given method of the Rosmaro model.
const inactiveButton = ({thisModel, text, method}) => <input
  type="button"
  className="nav-button"
  value={text}
  onClick={() => thisModel[method]()}
  />;

// Builds an active button.
const activeButton = ({text}) => <input
  type="button"
  className="nav-button active"
  value={text}
  />;

// Navigation when *all* items are selected.
const NavigationAll = {
  ...navigationHandlers,
  render: ({thisModel}) => ({
    // How does it *look*.
    UI: <div>
      {activeButton({text: 'All'})}
      {inactiveButton({thisModel, text: 'Done', method: 'navigateToDone'})}
      {inactiveButton({thisModel, text: 'Undone', method: 'navigateToUndone'})}
    </div>,
    // A function which is going to pick just selected items.
    show: map(prop('all'))
  })
};

// Navigation when *undone* items are selected.
const NavigationUndone = {
  ...navigationHandlers,
  render: ({thisModel}) => ({
    // How does it *look*.
    UI: <div>
      {inactiveButton({thisModel, text: 'All', method: 'navigateToAll'})}
      {inactiveButton({thisModel, text: 'Done', method: 'navigateToDone'})}
      {activeButton({text: 'Undone'})}
    </div>,
    // A function which is going to pick just selected items.
    show: map(prop('undone'))
  })
};

// Navigation when *done* items are selected.
const NavigationDone = {
  ...navigationHandlers,
  render: ({thisModel}) => ({
    // How does it *look*.
    UI: <div>
      {inactiveButton({thisModel, text: 'All', method: 'navigateToAll'})}
      {activeButton({text: 'Done'})}
      {inactiveButton({thisModel, text: 'Undone', method: 'navigateToUndone'})}
    </div>,
    // A function which is going to pick just selected items.
    show: map(prop('done'))
  })
};

// The main (most outer) node of the Rosmaro model.
const main = {
  // When the app starts, there are no items and the entered text is empty.
  initCtx: {
    newItemText: '',
    items: []
  },
  // Putting the form, list of items to do and the navigation together.
  afterRender: ({res}) => 
    <div className="container">
      {res.NewItemForm}
      <ul class="todos">
        {
          // Navigation provides a function which 
          // given all items (from the *Items* dynamic composite) 
          // extracts only these ones 
          // which are meant to be displayed.
          res.Navigation.show(res.Items)
        }
      </ul>
      {res.Navigation.UI}
    </div>
};

// All pieces of behavior which are going to be associated with the graph.
const handlers = {
  main,
  NewItemFormView,
  Items,
  Item,
  DoneItem,
  UndoneItem,
  NavigationAll,
  NavigationDone,
  NavigationUndone
};

// Everything required to build a Rosmaro model.
const rosmaroOpts = {
  graph,
  handlers,
  storage: makeStorage(),
  lock: makeLock()
};

// Rendering a React app based on a Rosmaro model.
ReactDOM.render(<RosmaroReact {...rosmaroOpts} />, document.getElementById('root'));
registerServiceWorker();
